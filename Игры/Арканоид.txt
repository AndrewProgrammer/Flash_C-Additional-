#include <iostream>
#include <Windows.h>
#include <conio.h>//эта библиотека помимо _getch() подтягивает функцию _kbhit()
using namespace std;
void main()
{
	int width = 50, height = 30;//параметры, отвечающие за ширину и высоту поля
	int color_text = 16, color_fon = 1;
	int xPos = width / 2, yPos = height / 2;//координаты движимого объекта
	int dx = -1, dy = -1;//параметры вектора - приращения по осям координат (по умолчанию вправо)
	int px = 1, py = 0;
	int xp = 25, yp = 28;
	int pw = 5;
	int a = 3;
	int xser = 47, yser = 31;
	//время в миллисекундах, отвечающее за частоту движения объекта
	int sleep_time = 1;
	//символ объекта
	char symbol = 299, platf = 45, ser = 3;
	COORD start = { 0, 0 };//создание объекта координат для хранения позиции старта
	HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);//создание "хендла" консоли
	CONSOLE_CURSOR_INFO cci = { sizeof(cci), false };//создаем объект, содержащий настройки для хендла с указанием не отображать курсор
	SetConsoleCursorInfo(h, &cci);//связываем хендл с объектом настройки
	bool flag = true;//переменная, управляющая ходом главного цикла
	do//начало главного цикла
	{
		for (int y = 0; y < height; y++)//начинаем цикл, который будет отвечать за отображение строк
		{
			for (int x = 0; x < width; x++)//вкладываем в цикл выше цикл, отвечающий за печать символов в пределах строки
			{
				char s;//объявляем символ, который будем выводить - осталось выяснить, что это будет за символ
				if (x == 0 && y == 0)//в верхнем левом углу поля - символ соответствующего угла
					s = 218;
				else if (x == 0 && y == height - 1)//нижний левый угол
					s = 192;
				else if (y == 0 && x == width - 1)//верхний правый угол
					s = 191;
				else if (y == height - 1 && x == width - 1)//нижний правый угол
					s = 217;
				else if (y == 0 || y == height - 1)//верхняя и нижняя граница поля
					s = 196;
				else if (x == 0 || x == width - 1)//левая и правая граница поля
					s = 179;
				else if (x == xPos&&y == yPos)//позиция, в которой должен находиться объект
					s = symbol;
				else if (x == xp  && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xp + 2 && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xp - 2 && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xp - 1 && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xp + 1 && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xp + 3 && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xp - 3 && y == yp)//позиция, в которой должен находиться объект
					s = platf;
				else if (x == xser && y == yser)
					s = ser;
				else s = ' ';//во всех остальных случаях должен быть просто пробел (означает пустую область поля)
				putchar(s);//выводим символ
			}
			cout << endl;//после пропечатывания всех символов строки - переходим на следующую строку
		}
		Sleep(sleep_time);//выдерживаем паузу
		if (_kbhit())//проверяем, была ли нажата какая-либо клавиша и запускаем её обработку в случае ИСТИНЫ
		{
			int k = _getch();//считываем код клавиши из буфера
			if (k == 0 || k == 224)//если первый код - вспомогательный, считываем второй код
				k = _getch();
			switch (k)//пропускаем код нажатой клавиши внутрь оператора выбора
			{
			case 75://есди влево
				color_fon = 14;
				xp -= px;
				break;
			case 77://если вправо
				color_fon = 10;
				xp += px;
				break;
			case 27://если была нажата клавиша ESC
				flag = false;//устанавливаем флажок на ЛОЖЬ, чтоб закончить показ движения
				break;
			}
			if (xp < 4)
				xp = 4;
			else if (xp >= width - 5)
				xp = width - 5;
			SetConsoleTextAttribute(h, color_fon);
		}
		xPos += dx;//приращаем горизонтальную позицию объекта
		yPos += dy;//приращаем вертикальную
		if (yPos == 0)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;//чтоб он "ушел" срамки поля 
		}
		else if (xPos == 0 || xPos == width - 1)
		{
			dx = -dx;//меняем вектор движения на противоположный
			dy = dy;//для этого меняем знак обоих приращений
			xPos += dx;//как бы двигаем позицию объекта в обратном направлении
			yPos -= dy;//чтоб он "ушел" срамки поля 
		}
		else if (yPos == 0 && xPos == height - 1)
		{
			dx = -dx;//меняем вектор движения на противоположный
			dy = dy;//для этого меняем знак обоих приращений
			xPos += dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;//чтоб он "ушел" срамки поля 
		}
		else if (yPos == height - 1)
		{

			a--;
			if (a >= 0)
			{
				color_fon = 12;
				xPos = width / 2;
				yPos = height / 2;
				dx = 1;
				dy = -1;
				SetConsoleTextAttribute(h, color_fon);
			}
			else
			{
				system("cls");//очищаем экран
				cout << "Program is ended\n";//выводим сообщение о конце игры
			}
		}
		else if (xPos == xp && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}
		else if (xPos == xp + 1 && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}
		else if (xPos == xp - 1 && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}
		else if (xPos == xp + 2 && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}
		else if (xPos == xp - 2 && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}
		else if (xPos == xp + 3 && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}
		else if (xPos == xp - 3 && yPos == yp)
		{
			dx = dx;//меняем вектор движения на противоположный
			dy = -dy;//для этого меняем знак обоих приращений
			xPos -= dx;//как бы двигаем позицию объекта в обратном направлении
			yPos += dy;
		}

		if (xp == width - 1)
		{
			xp = px;
		}
		else if (xp == 0)
		{
			xp = width - 1;
		}
		if (a >= 0)
			cout << "\t\t\t\t\t       " << ser << (char)42 << a;
		else
		{
			cout << "\t\t    " << "GAME OVER!!!";
		}
		SetConsoleCursorPosition(h, start);//отправляем курсор в начало координат консоли
	} while (flag);//выходим из цикла, если была нажата клавиша ESC
	system("cls");//очищаем экран
	cout << "Program is ended\n";//выводим сообщение о конце игры
	//у кого консоль сворачивается сама при выходе из программы - добавляем вспомогательный вызов функции _getch()
}